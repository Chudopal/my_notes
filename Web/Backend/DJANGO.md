# DJANGO:
[примеры кода можно посмотреть здесь](https://github.com/Chudopal/Django_learning)

[докуметация Django](https://docs.djangoproject.com/en/3.0/)

**Django - это фреймворк для backend разработки, написанный на python.**
+ [Настройка виртуальной среды](#settings_of_env)
+ [Основные термины](#basics_termins)
+ [Основные команды Django](#basic_commands_django)
+ [Создание проекта и приложения](#make_model_and_app)
+ [Модели Django](#models_of_django)
  + [Создание моделей](#create_model)
  + [Немного про внешний ключ](#forignkey)
  + [Добавление моделей в abmin.py](#add_in_admin)
  + [Настройка отображения моделей](#display_of_models)
+ [Устновка postgresql](#install_psql)
+ [Работа с оболочкой](#query_set)
+ [Обработчики Django](#handl)
  + [views.py](#look_of_site)
  + [Добавление шаблонов URL](#urltemp)
+ [Djando-forms](#django_forms)
+ [Django шаблоны](#templates)
  + [Переменные](#var)
  + [Фильтры](#filters)
  + [Теги](#tags)
+ [Сессии](#sessions)
+ [Развертывание](#deployment)
+ [Как пакетировать приложение](#package)
+ [Debug tools](#debug)

## <a name="settings_of_env"></a> Настройка виртуальной среды
+ Для того, чтобы начать Django-проект желательно сделать виртуальную среду и установить в ней Django.
+ Для того, чтобы уcтановить виртуальную среду необходимо создать папку, в которой в консоли прописать: `python3 -m venv name_of_env` 
+ Далее для работы необходимо активировать виртуальную среду:
`source name_of_env/bin/activate`
+ На то, что среда активированна укажет ее название перед именем пользователя в скобках в терминале:
`(name_of_env) alexandr@alexandr-VivoBook-15-ASUS-Laptop-X570UD:~/git_hub/django/blogsite$`
+ Чтобы деактивировать среду, надо просто прописать в терминале:
`deactivate`
+ Перед тем как установить Django желательно обновить pip;
`python3 -m pip install --upgrade pip`
+ Для установки Django версии 2.0.5 необходимо прописать в терминале:
`pip install Django==2.0.5`
+ Для того, чтобы посмотреть какие пакеты с их версиями установленны в среде необходимо выполнить команду:
`pip freeze`

## <a name="basics_termins"></a> Основные термины
В Django *проект* – это код, созданный с использoванием Django и содержащий некоторые настройки. 

*Приложение* – это набор модулей, описывающих модели, обработчики запросов, шаблоны и конфигурации URL’ов. Приложение взаимодействует с фреймворком, предоставляя некоторую функциональность, и может быть многократно использовано в других проектах. Мы можем сопоставить проект с сайтом, который состоит из
нескольких приложений (блога, раздела вопросов, форума), каждое из которых
может быть использовано и в других проектах.

*Миграции* - это что-то вроде системы контроля версий для базы данных. Они позволяют команде программистов изменять структуру БД, в то же время оставаясь в курсе изменений других участников. Миграции обычно идут рука об руку с конструктором таблиц для более простого обращения с архитектурой вашего приложения.

*QuerySet* — список объектов заданной модели. QuerySet позволяет читать данные из базы данных, фильтровать и изменять их порядок.

## <a name="basic_commands_django"></a> Основные команды Django
Команды просто писать в терминале:

+ **`source name_of_env/bin/activate`** - активация виртуальной среды.
+ **`deactivate`** - деактивация виртуальной среды.
+ **`django-admin startproject mysite`** - создание проекта  mysite.
+ **`python manage.py runserver`** - запуск сервера. 
+ **`python manage.py startapp blog`** - создание приложения blog.
+ **`python manage.py makemigrations blog`** - инициализирующая миграция, ее нужно делать всякий раз после изменения models.py.
+ **`python manage.py sqlmigrate blog 0001`** - выводит SQL код миграции 0001 в консоль.
+ **`python manage.py migrate`** - синхронизация базы данных. Применение миграции для всех приложений, указанных в INSTALLED_APPS, файла setting.py.
+ **`python manage.py createsuperuser`** - создание сайта администрирования. На нем можно управлять всеми моделями, которые в нем определены.
+ **`python manage.py shell`** - открыть оболочку.

## <a name="make_model_and_app">  Создание проекта и приложения
**`django-admin startproject mysite`** - создание проекта  mysite.
После создания проекта в директории появится папка mysite, в которой будет следующее содержимое:
```
mysite/ 
    manage.py           - утилита командной строки для управления проектом.
    mysite/             - сама папка проекта.
        _init__.py      - говорит Python о том, что mysite является Python-пакетом.
        settings.py     - конфигурация проекта.
        urls.py         - здесь будут содержаться шаблоны адресов.
        wsgi.py         - конфигурация для запуска проекта как WSGI-приложения.

```
Далее можно посмотреть, успешно ли создался проект, для этого необходмо его запустить:
**`python manage.py runserver`** - запуск сервера, по умолчанию он доступен по адресу `127.0.0.1:8000` или `localhost:8000`, чтобы изменить адрес или файл кофигурации нужно в консоле запустить сервер следующим образом: `python manage.py runserver 127.0.0.1:8001 --settings=mysite.settings`

**`python manage.py startapp blog`** - создание приложения blog. Приложения - это блоки проекта.
```
blog/
    __init__.py
    admin.py            - регистрируем модели для добавления их в систему администрирования Django.
    apps.py             - файл, содержащий основную конфигурацию приложения blog.
    migrations/         - папка, содержащая миграции базы данных приложения.
        __init__.py
    models.py           - модели данных приложения.
    tests.py            - файл для тестов приложения.
    views.py            - вся логика хранится здесь.
```
+ Чтобы приложение blog было видно Django, необходимо добавить 
*blog.apps.BlogConfig* в настройку INSTALLED_APPS в файле settings.py. 
Класс BlogConfig – это конфигурация приложения.

## <a name="models_of_django"></a> Модели Django
**Модели** отображают информацию о данных, с которыми вы работаете. Они содержат поля и поведение ваших данных. Обычно одна модель представляет одну таблицу в базе данных.

Основы:
+ Каждая модель это класс унаследованный от *django.db.models.Model*.
+ Атрибут модели представляет поле в базе данных.
+ Django предоставляет автоматически созданное API для доступа к данным.
### <a name="create_model"></a> Создание моделей 
Модели описываются в файле models.py:
```python
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User

# Create your models here.

class Post(models.Model):
    """Класс для формирования модели поста в базе данных.
    Если вдруг происходит изменение здесь,
    необходимо пересобрать базу данных"""

    STATUS_CHOICES = ( 
        ('draft','Draft'),  
        ('published','Published'),
    )
    title = models.CharField(max_length=250) #заголовок статьи, базе данных пребразуется в обычный VARCHAR
    slug = models.SlugField(max_length=250, unique_for_date='publish') #Поле для формаирования URL-ов. unique_for_date - для формирования уникальных имен
    author = models.ForeignKey(User, on_delete=models.CASCADE, #внешний ключ,определеят отношение "один ко многим".  
                               related_name='blog_posts')#on_delete -определяет поведение при удалиении пользователя. CASCADE - удалять все посты пользоватля.
                                                         #related_name - имя обратной связи от User к Post. Так можно найти вязанные посты автора
    body = models.TextField()#основное содержание статьи.
    publish = models.DateTimeField(default=timezone.now) #поле даты, которое сохраняет дату публикации. datetime.now - возвращает текущую дату.
    created = models.DateTimeField(auto_now_add=True)#поле даты. указывает, когда статья была создана. auto_now_add - авто сохранение даты при создании объекта
    updated = models.DateTimeField(auto_now=True)#дата и время, когда статья была отредактирована. auto_now - дата будет сохраняться автоматически при создании объекта
    status = models.CharField(max_length=10,choices=STATUS_CHOICES,default='draft')#отображает статус статьи.  STATUS_CHOICES - отсюда будут браться варианты
    class Meta:
        """Метаданные
        Здесь мы указали, что статьи должны
        сортироваться по дате публикации"""

        ordering = ('-publish',)#"-" - означает что сортировка должна происходить по убыванию
        def __str__(self):
            return self.title
```
Каждое поле определено как атрибут класса, и каждый атрибут соответствует полю таблицы в базе данных.
После изменения модели необходимо прописать в терминале:
+ `python manage.py makemigrations name_of_app`
+ `python manage.py migrate`

### <a name="forignkey"></a> Немного про внешний ключ

Термин «внешний ключ» (foreign key) происходит из теории баз данных; внешний ключ содержит ссылку на другую запись в базе данных. Таким образом можно сделать иерархическую модель наподобии "Жанр - фильм" или "Топик - текст". В Django это можно релизовать вледующим образом:
```python
from django.db import models

# Create your models here.

class Topic(models.Model):
    """Тема, которую изучает пользователь"""
    text = models.CharField(max_length=200)
    date_added = models.DateTimeField(auto_now_add=True)
    def __str__(self):
        """Возвращает строковое представление модели."""
        return self.text


class Entry(models.Model):
    """Информация, изученная пользователем по теме"""
    topic = models.ForeignKey(Topic, on_delete=models.CASCADE) #ВНЕШНИЙ КЛЮЧ
    text = models.TextField()
    date_added = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        verbose_name_plural = 'entries'
    
    def __str__(self):
        """Возвращает строковое представление модели."""
        return self.text[:50] + "..."
``` 
В данном случае реализованна модель "многие-к-одному", так как множество различные записей(Entry) может принадлежать одной теме(Topic).

### <a name="add_in_admin"></a> Добавление моделей в admin.py
**`python manage.py createsuperuser`** - создание сайта администрирования. На нем можно управлять всеми моделями, которые в нем определены.
Чтобы приложение показывало свою модель на странице администрирования необходимо изменить
файл admin.py этого приложения таким образом:
```python
from django.contrib import admin
from .models import Post

admin.site.register(Post)
```
Где *Post* - это модель из приложения. Теперь на `localhost:8000/admin` можно добавить или удалить экземляры моделей данного приложения.

### <a name="display_of_models"></a> Настройка отображения моделей
Можно настривать отображение моделей в /admin, 
```python
from django.contrib import admin
from .models import Post

@admin.register(Post) #декоратор, то же самое что и admin.site.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_display = ('title', 'slug', 'author', 'publish','status') #столбцы таблицы
```
Так мы говорим Django, что наша модель зарегистрирована на сайте администрирования с помощью пользовательского класса, наследника `ModelAdmin`.

### <a name="install_psql"></a> Установка postgresql
0. Обязательно установить:
    ```
        sudo apt-get install python3-pip python3-dev libpq-dev postgresql postgresql-contrib
    ```
1. Создать базу данных и пользователя:
    1. Открыть pslq:
        ```
            sudo -u postgres psql
        ```
    2. Создать базу данных:
        ```
            postgres=# CREATE DATABASE myproject;
        ```
    3. Создать юзера:
        ```
            postgres=# CREATE USER myprojectuser WITH PASSWORD 'password';
        ```
    4. Устновить `utf-8`, так как джанго использует именно его:
        ```
            postgres=# ALTER ROLE myprojectuser SET client_encoding TO 'utf8';
        ```
    5. Уровень изолированности транзакций нужно по умолчанию установить как “read committed” (чтение фиксированных данных) – этот уровень обеспечивает защиту от чернового чтения:
        ```
            postgres=# ALTER ROLE myprojectuser SET default_transaction_isolation TO 'read committed';
        ```
    6. Установить `UTC`:
        ```
            postgres=# ALTER ROLE myprojectuser SET timezone TO 'UTC';
        ```
    7. Дать только что созданному пользователю права доступа к созданной базе:
    ```
        postgres=# GRANT ALL PRIVILEGES ON DATABASE myproject TO myprojectuser;
    ```
    8. Выход):
    ```
        postgres=# \q
    ```
2. При создании виртуальной среды и Django нужно так же установить **`psycopg2`**, который позволит использовать установленную ранее базу данных.
3. Зайти в файл **settings.py** своего проекта и изменить переменную **DATABASES**:
    ```py
    DATABASES = {
        'default': {
           'ENGINE': 'django.db.backends.postgresql_psycopg2',
           'NAME': 'myproject',
           'USER': 'myprojectuser',
           'PASSWORD': 'password',
           'HOST': 'localhost',
           'PORT': '',
        }
    }
    ```
    Сохранить и закрыть файл.


## <a name="query_set"></a> Работа с оболочкой
Django ORM основана на объектах запросов *QuerySet*. QuerySet – это коллекция объектов, полученных из базы данных. К ней могут быть применены фильтрация и сортировка.
+ Чтобы добавить объект в БД, необходимо открыть терминал и прописать `python manage.py shell`,затем прописать следующие строки:
    ```python
    >>> from django.contrib.auth.models import User
    >>> from blog.models import Post
    >>> user = User.objects.get(username='admin') #ищем пользователя с таким именем
    >>> post = Post(title='Another post', slug='another-post',
    body='Post body.', author=user)
    >>>post.save()#сохраняем объект в базу данных
    ``` 
+ Чтобы получить доступ ко все объектам БД необходимо прописат: 
    ```>>> all_posts = Post.objects.all()```
+ Чтобы получить все объекты модели в виде list, необходимо прописать:
    ```>>> list(Post.objects.values())```
+ Методы сортировки:
  + *filter()*:
    `Post.objects.filter(publish__year=2017)` - сортировка записей из 2017 года.
    **Условия фильтрации строятся с использованием двойного подчеркивания например publish__year.**
  + *exclude()*:
    фильтр имключения, т е мы исключаем все записи, которые подходят под него: `Post.objects.filter(publish__year=2017).exclude(title__startswith='Why')`
  + *order_by()*:
    для сортировки по полям: `Post.objects.order_by('title')` - алфавитном порядке, `Post.objects.order_by('-title')` - в обратном порядке.
+ Чтобы удалить объект:
    *delete()*: 
    ```python
    post = Post.objects.get(id=1)
    post.delete()
    ```
    Бывают случаи(очень часто), когда необходим доступ по внешнему ключу:
    ```python
    >>>t = Topic.objects.get(id=1)
    >>>t.entry_set.all()
    ```
    В данном случае в классе *Entry* есть поле `topic = models.ForeignKey(Topic, on_delete=models.CASCADE)`, т.е. внешний ключ к классу Topic.
    Чтобы получить данные через отношение внешнего ключа, необходимо использовать имя связанной модели, записанное в нижнем регистре, за которым следует символ
    подчеркивания и слово set.

## <a name="handl"></a> Обработчики Django
Обработчик Django – это простая Python-функция, которая получает веб-запрос и возвращает веб-ответ. Вся логика, формирующая желаемый ответ, описывается внутри этой функции. Каждый обработчик генерирует шаблон, используя переменные контекста, и возвращает HTTP-ответ со сформированной HTML-страницей.

### <a name="look_of_site"></a> views.py
Функция представления или обработчики получает информацию из запроса, подготавливает данные, необходимые для построения страницы, и возвращает данные браузеру — часто
с использованием шаблона, определяющего внешний вид страницы.
Обработчики необходимо описывать в `views.py`:
```python
def post_list(request):
    """Обработчик для отображения списка статей

    request - обязателен для всех обработчиков
    В этой функции мы запрашиваем 
    из БД все опубликованные статьи с помощью
    менеджера published
    """
    posts = Post.published.all()#запрос из бд
    return render(              #формирует шаблон со списка статей
        request,                #принимает объект запроса request,  
        'blog/post/list.html',  #путь к шаблону
        {'posts':posts}         #и переменные контекста для этого шаблона.     
    )

```
Во `views.py` мы описываем логику реакции на запрос, а frontend формируется в папке template приложения. Мы используем функцию render() для формирования шаблона. Она принимает объект запроса **request**, **путь к шаблону** и **переменные контекста** для этого шаблона. В ответ вернется объект HttpResponse со сформированным текстом (обычно это HTML-код). Функция render() использует переданный контекст при формировании шаблона, поэтому любая
переменная контекста будет доступна в шаблоне. *Процессоры контекста – это вызываемые функции, которые добавляют в контекст переменные.*

### <a name="urltemp"></a> Добавление шаблонов URL
Обычно процесс создания веб-страниц в Django состоит из трех стадий: опреде ления URL, написания представлений и написания шаблонов. Сначала следует определить схемы (patterns) URL. Схема URL описывает структуру URL-адреса и сообщает Django, на какие компоненты следует обращать внимание при сопоставлении запроса браузера с URL-адресом на сайте, чтобы выбрать возвращаемую страницу.
Затем каждый URL-адрес связывается с конкретным представлением — функция представления читает и обрабатывает данные, необходимые странице. Функция
представления часто вызывает шаблон, который строит страницу, подходящую для передачи браузеру.
Шаблоны URL’ов позволяют сопоставить адреса с обработчиками. Шаблон представляет собой комбинацию из строки, описывающей адрес, обработчика и необязательного названия, которое даст возможность обращаться к этому шаблону на всех уровнях проекта. Django проходит по порядку по всем шаблонам,пока не найдет первый подходящий, т. е. совпадающий с URL’ом запроса. Затем Django сможет импортировать соответствующий обработчик и выполнить его, передав внутрь объект запроса HttpRequest и ключевые слова или позиционные аргументы.
Для этого необходимо в папке приложени создать файл `urls.py`(Любое значение, определенное в шаблоне как `<parameter>`, возвраща-
ется в виде строки):
```python
    from django.urls import path
    from . import views
    app_name = 'blog'#ОПРЕДЕЛЕНИЕ ПРОСТРАНСТВА ИМЕН

    urlpatterns = [
    # post views
    path('', views.post_list, name='post_list'),#вызов обработчика
    path('<int:year>/<int:month>/<int:day>/<slug:post>/',
    views.post_detail, name='post_detail'), 
    ]
```
Так же необходимо отредактировать `urls.py`, который находится в радительском каталоге:
```python
    from django.urls import path, include
    from django.contrib import admin

    urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls', namespace='blog')),#именно здесь мы добавили юрлы приложения
    ]
```

**`include - подключает конфигурацию приложения.`**

**`RedirectView.as_view(url='/catalog/', permanent=True))` - перенаправляет с корневого URLa в данном приложении на указанный в дужках**

**`static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)` - используется для разрешения статических файлов**

В Django есть соглашение о том, что метод модели get_absolute_url() должен возвращать канонический URL объекта:
```python
    from django.urls import reverse
    class Post(models.Model):
    # ...
    def get_absolute_url(self):
        return reverse('blog:post_detail', args=[self.publish.year,
        self.publish.month, self.publish.day, self.slug])
```



## <a name="django_forms"></a> Django-forms

Django имеет встроенную *подсистему* форм, которая позволяет легко управлять ими.
Эта подсистема дает возможность описать поля формы, указать, как они будут
отображаться и как будет проверяться корректность данных.

В  Django встроеены два базовых класса форм:
+ **Form** - позволяет создавать стандартные формы.
+ **ModelForm** - дает возможность создавать формы по объектам моделей.

Формы могут быть описаны в любом месте вашего проекта, но есть общее соглашение,
чтобы они находились в файле **forms.py** каждого приложения:
```python
from django import forms

class EmailPostForm(forms.Form):
    """Класс для формы заполнения эмейла"""
    name = forms.CharField(max_length=25)
    email = forms.EmailField()
    to = forms.EmailField()
    comments = forms.CharField(required=False,widget=forms.Textarea)
```

Далее необходимо изменить файл **views.py**, чтобы обрабатывал данную форму:
```python
def post_share(request, post_id):
    # Получение статьи по идентификатору.
    post = get_object_or_404(Post, id=post_id,status='published')
    if request.method == 'POST':
        # Форма была отправлена на сохранение.
        form = EmailPostForm(request.POST)
    if form.is_valid():
        # Все поля формы прошли валидацию.
        cd = form.cleaned_data
        # ... Отправка электронной почты.
    else:
        form = EmailPostForm()
        return render(request, 'blog/post/share.html',
            {'post': post, 'form': form})

```

## <a name="templates"></a>Шаблоны
Шаблоны Django - это просто текстовый файл или строка Python, которые следуют языку шаблонов Django
Синтаксис языка шаблонов Django спользует 4 конструккции:
+ Переменные: `{{variable}}`
+ Фильтры:`{{variable|filter}}`
+ Теги:`{%...%}`
+ Комментарии:{#comment#}

### <a name="var"></a>Переменные
Переменные выглядят таким образом: {{ variable }}. Когда шаблон встречает переменую, он вычисляет ее и заменяет результатом. Названия переменных могут состоять из букв, цифр и нижнего подчеркивания("_"). Если использовать точку, то можно получить доступ к:
+ Ключ словаря
+ Атрибут
+ Вызов метода
+ Индекс списка
Если переменная не найдена, шаблон вставит значение из настройки TEMPLATE_STRING_IF_INVALID, которая равна '' (пустой строке) по-умолчанию.

Передача переменных производится при помощи передачи словаря с переменными в функцию **render()**, он присвивается свойству **context**:
+ views.py:
    ```python
    from django.shortcuts import render

    def index(request):
        data = {"header": "Hello Django",   "message": "Welcome to Python"}
        return render(request, "index.html",    context=data)
    ```
+ index.html:
    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <title>Hello Django</title>
    </head>
    <body>
        <h2>{{ header }}</h2>
        <p>{{ message }}</p>
    </body>
    </html>
    ```
### <a name="filters"></a>Фильтры
Вы можете изменить значение переменной используя фильтры.

Фильтры выглядят таким образом: `{{ name|lower }}`. Это выведет значение переменной `{{ name }}` после применения фильтра lower к нему, который преобразует значение в нижний регистр. Используйте символ (|) для применения фильтра.
Можно использовать “цепочку” фильтров. Вывод одного фильтра используется для другого. `{{ text|escape|linebreaks }}` обычно применяется для экранирования текста, и замены переноса строки тегами `<p>`.
Некоторые фильтры принимают аргументы. Аргумент фильтра выглядит таким образом: `{{ bio|truncatewords:30 }}`. Этот код отобразит первые 30 слов переменной bio.
Аргументы фильтров, которые содержат пробелы, должны быть заключены в кавычки. Например, что бы объединить список пробелом и запятой, используйте `{{ list|join:", " }}`.
### <a name="tags"></a>Теги
Теги выглядят таким образом: **`{% tag %}`**. Теги сложнее чем переменные: одни создают текст для вывода, влияют на выполнение используя условия и циклы, другие загружают дополнительную информацию в шаблоны что бы использовать ее далее через переменные.
Некоторые теги требуют открывающий и закрывающий теги (например, `{% tag %} ... содержимое тега ... {% endtag %}`).


## <a name="sessions"><a> Сессии
Ниже представлены фрагменты кода, которые показывают вам как получать, задавать и удалять некоторые данные при помощи ключа "my_car", связанного с текущей сессией (браузером):

```python
# Получение значения сессии при помощи ключа(то есть, 'my_car'). 
# Если такого ключа нет, то возникнет ошибка KeyError
my_car = request.session['my_car']

# Получение значения сессии. Если значения не существует,
# то вернется значение по умолчанию ('mini')
my_car = request.session.get('my_car', 'mini')

# Передача значения в сессию
request.session['my_car'] = 'mini'

# Удаление значения из сессии
del request.session['my_car']
```
По умолчанию Django сохраняет данные сессии в базу данных и отправляет соответствующие куки клиенту только тогда, когда сессия была изменена, или удалена. Если вы обновляете какие-либо данные при помощи ключа сессии, как показано в предыдущем фрагменте, тогда вам не надо беспокоиться о процессе сохранения! Например:
```python
# Данное присваивание распознается как обновление сессии 
# и данные будут сохранены
request.session['my_car'] = 'mini'
```
Если вы обновлете информацию внутри данных сессии, тогда Django не распознает эти изменения и не выполнит сохранение данных (например, если вы изменили "wheels" внутри переменной "my_car", как показано ниже). В таких случаях вам надо явно указывать, что сессия была изменена:
```python
# Объект сессии модифицируется неявно. 
# Изменения НЕ БУДУТ сохранены!
request.session['my_car']['wheels'] = 'alloy'

# Явное указание, что данные изменены. 
# Сессия будет сохранена, куки обновлены (если необходимо).
request.session.modified = True
```


## <a name="deployment"><a> Развертывание
В **settings.py**:
  + **DEBUG** - при развертывании сайта должен быть установлен в **False** (DEBUG = False). Тем самым, прекратится вывод  важной отладочной информации.
  + **SECRET_KEY** - важно, чтобы ключ, используемый в продакшине, не указывался в исходном коде, и/или не запрашивался с другого сервера. Django рекомендует размещать значение ключа либо в переменной окружения, или в файле с доступом только на чтение.

## <a name="package"><a> Как пакетировать приложение
  
## <a name="debug"></a> Debug tools
- django-debug-toolbar - добавляет панель инструментов в ваш браузер, которая покажет вам много отладочной информации во время работы вашего проекта. Используя его, вы можете увидеть количество запросов SQL, которые были выполнены. Также возможно проверить эти запросы, проверить код SQL и посмотреть, в каком порядке они выполнялись и сколько времени занимал каждый из них. Добавление: https://django-debug-toolbar.readthedocs.io/en/latest/installation.html
- django-silk - Он перехватывает запросы, записывает выполненные SQL-запросы и предоставляет способ их визуализации. Вы сможете просматривать запросы, просматривать список выполненных SQL-запросов и смотреть подробную информацию о конкретном запросе, в том числе о том, какая строка кода вызвала выполнение определенного запроса. Сохраняет все данные в БД. Добавление: https://pypi.org/project/django-silk/#installation
- connection.queries - Когда установлен debug = True, можно получить доступ к запросам, которые были выполнены, через connection.queries:
  ```py
  >>> from django.db import connection
  >>> Post.objects.all()
  >>> connection.queries
  [
     {
        'sql': 'SELECT "blogposts_post"."id", "blogposts_post"."title", '
               '"blogposts_post"."content", "blogposts_post"."blog_id", '
               '"blogposts_post"."published" FROM "blogposts_post" LIMIT 21',
        'time': '0.000'
     }
  ]
  ```
  Способ очистки:
  ```py
  >>> from django.db import reset_queries
  >>> reset_queries()
  ```
- Можно посмотреть query и в самом queryset:
  ```py
  >>> from accounts.models import Author
  >>> q1 = Author.objects.all()
  >>> str(q1.query)  
  'SELECT "accounts_author"."id", "accounts_author"."pseudonym", "accounts_author"."name" FROM "accounts_author"'
  ```
